#region Prolog

#################################################################
## IBM Confidential
##
## OCO Source Materials
##
## BI and PM: pmpsvc
##
## (C) Copyright IBM Corp. 2008, 2009, 2010
##
## The source code for this program is not published or otherwise
## divested of its trade secrets, irrespective of what has been
## deposited with the U.S. Copyright Office.
#################################################################

cControlPrefix = '}';

#*** Log File Name
cTM1Process =GetProcessName();
StringGlobalVariable('gPrologLog');
StringGlobalVariable('gEpilogLog');
StringGlobalVariable('gDataLog');
vReturnValue = ExecuteProcess(cControlPrefix | 'tp_get_log_file_names',
'pExecutionId', pExecutionId, 'pProcess', cTM1Process, 'pControl', 'Y');
If (vReturnValue <> ProcessExitNormal());
	ProcessError;
EndIf;
cPrologLog = gPrologLog;
cEpilogLog = gEpilogLog;
cDataLog = gDataLog;
cTM1Log = cPrologLog;

cConfigDim = cControlPrefix | 'tp_config';
If (DimensionExists(cConfigDim) = 1);
	cGenerateLog = ATTRS(cControlPrefix | 'tp_config', 'Generate TI Log', 'String Value');
Else;
	cGenerateLog = 'N';
EndIf;

#*** Log Parameters

If (cGenerateLog @= 'Y');
	TextOutput(cTM1Log, TIMST(NOW, '\Y-\m-\d \h:\i:\s'), 'Parameters:',
		pExecutionId, pAppId,  pSourceFile, pCubeInfo);
EndIf;

#*** Set local variables

DataSourceType = 'CHARACTERDELIMITED';
DatasourceASCIIDelimiter = CHAR(9);
DatasourceASCIIHeaderRecords = 0;
DatasourceNameForServer = pSourceFile;

If (cGenerateLog @= 'Y');
	TextOutput(cTM1Log, 'DataSourceType: ' | DataSourceType);
	TextOutput(cTM1Log, 'DatasourceASCIIDelimiter: ' | DatasourceASCIIDelimiter);
	TextOutput(cTM1Log, 'DatasourceASCIIHeaderRecords: ' | NumberToString(DatasourceASCIIHeaderRecords));
	TextOutput(cTM1Log, 'DatasourceNameForServer: ' | DatasourceNameForServer);
EndIf;

#*** Set input file encoding as UTF-8

SetInputCharacterSet('TM1CS_UTF8');

#***
cApprovalDim =  ATTRS('}tp_applications', pAppId,  'ApprovalDimension');
cApprovalSubset =ATTRS('}tp_applications', pAppId,  'ApprovalSubset');
cSecuritySet = ATTRS('}tp_applications', pAppId,  'SecuritySet');
cShadowApprovalDim = '}tp_tasks}' | pAppId;
cVersionDim = ATTRS('}tp_applications', pAppId, 'VersionDimension');
cVersionSlicesWrite =ATTRS('}tp_applications', pAppId, 'VersionSlicesWrite');
cVersionSlicesRead =ATTRS('}tp_applications', pAppId, 'VersionSlicesRead');

If (cGenerateLog @= 'Y');
	TextOutput(cTM1Log, TIMST(NOW, '\Y-\m-\d \h:\i:\s'), 
		'tp_get_application_attributes', cApprovalDim, cApprovalSubset, 
		cSecuritySet,cShadowApprovalDim,cVersionDim, cVersionSlicesWrite, cVersionSlicesRead );
EndIf;

#***
IF (cVersionDim @<> '' & cVersionSlicesWrite @= '');
	vReturnValue = ExecuteProcess(cControlPrefix | 'tp_error_update_error_cube', 
		'pGuid', pExecutionId, 
		'pProcess', cTM1Process, 
		'pErrorCode', 'TI_APP_WRITABLE_CONTROL_SLICES_UNDEFINED',
		'pErrorDetails', pAppId,
		'pControl', 'Y');
	
	ProcessError;
Endif;

#***
cApplicationsDim = cControlPrefix | 'tp_applications';
cAppElementSecurityCube = '}ElementSecurity_' | cApplicationsDim;
cElementSecurityCube = '}ElementSecurity_' | cShadowApprovalDim;

cPermissionsDim = cControlPrefix | 'tp_permissions';
cPermissionCube = cControlPrefix | 'tp_application_permission}' | pAppId;
cCellSecurityCube = '}CellSecurity_' | cPermissionCube;

vAppDim = '}tp_intermediate_security_applications';

#***
IF (CubeExists(cElementSecurityCube )>0);
	CubeSetLogChanges(cElementSecurityCube , 0);
Endif;

IF (CubeExists(cCellSecurityCube )>0);
	CubeSetLogChanges(cCellSecurityCube , 0);
Endif;

cubeSeparater = '*';
vPosCube = 0;
vStringToScan = pCubeInfo;
vPosCube = SCAN(cubeSeparater, vStringToScan);

While (vPosCube >0);
	vCubeName = SUBST(vStringToScan, 1, vPosCube-1);
	vFlagCube = SUBST(vStringToScan, vPosCube+1, 1);
	
	If (vFlagCube @= 'A' );
		vRDCLSIntermediateCube = '}tp_intermediate_RDCLS}' | vCubeName;
		
		IF (cubeExists(vRDCLSIntermediateCube) >0);
			CubeSetLogChanges(vRDCLSIntermediateCube, 0);
		Endif;
	Endif;

	vStringToScan = SUBST(vStringToScan, vPosCube +3, LONG(vStringToScan)-vPosCube);
	vPosCube = SCAN(cubeSeparater, vStringToScan);
End;

#***
If (cGenerateLog @= 'Y');
	TextOutput(cTM1Log, 'Check application dimension');
EndIf;

If (DimensionExists(cApplicationsDim) = 0);
	vReturnValue = ExecuteProcess(cControlPrefix | 'tp_error_update_error_cube',
	'pGuid', pExecutionId,
	'pProcess', cTM1Process,
	'pErrorCode', 'TI_DIM_NOT_EXIST',
	'pErrorDetails', cApplicationsDim,
	'pControl', 'Y');
	
	ProcessError;
EndIf;

#***
If (cGenerateLog @= 'Y');
	TextOutput(cTM1Log, 'Check application id', pAppId);
EndIf;

If (DIMIX(cApplicationsDim, pAppId) = 0);
	vReturnValue = ExecuteProcess(cControlPrefix | 'tp_error_update_error_cube',
	'pGuid', pExecutionId,
	'pProcess', cTM1Process,
	'pErrorCode', 'TI_NODE_NOT_EXIST',
	'pErrorDetails', cApplicationsDim | ', ' | pAppId,
	'pControl', 'Y');
	
	ProcessError;
EndIf;

#***
vAppSubset = 'temp_app_' | pAppId;
IF (SubsetExists(cApplicationsDim, vAppSubset)>0);
	subsetDestroy(cApplicationsDim, vAppSubset);
Endif;
SubsetCreate(cApplicationsDim, vAppSubset);
SubsetElementInsert(cApplicationsDim, vAppSubset, pAppId, 1);

#***
vAppSubset = 'temp_app_' | pAppId;
IF (SubsetExists(vAppDim, vAppSubset)>0);
	SubsetDestroy(vAppDim, vAppSubset);
Endif;
SubsetCreate(vAppDim, vAppSubset);
SubsetElementInsert(vAppDim, vAppSubset, pAppId, 1);

#***
If (cGenerateLog @= 'Y');
	TextOutput(cTM1Log, 'Check permission cube');
EndIf;
	
cPermissionCube = cControlPrefix | 'tp_application_permission}' | pAppId;
If (CubeExists(cPermissionCube) = 0);
	vReturnValue = ExecuteProcess(cControlPrefix | 'tp_error_update_error_cube',
	'pGuid', pExecutionId,
	'pProcess', cTM1Process,
	'pErrorCode', 'TI_CUBE_NOT_EXIST',
	'pErrorDetails', cPermissionCube,
	'pControl', 'Y');
	
	ProcessError;
EndIf;

#***
If (cGenerateLog @= 'Y');
	TextOutput(cTM1Log, 'Check cell security permission cube');
EndIf;

cCellSecurityCube = '}CellSecurity_' | cPermissionCube;

If (CubeExists(cCellSecurityCube) = 0);
	vReturnValue = ExecuteProcess(cControlPrefix | 'tp_error_update_error_cube',
	'pGuid', pExecutionId,
	'pProcess', cTM1Process,
	'pErrorCode', 'TI_CUBE_NOT_EXIST',
	'pErrorDetails', cCellSecurityCube,
	'pControl', 'Y');
		
	ProcessError;
EndIf;

#***
#IF this is an incremental security update, 
#We need to create a temp dimension that records all nodes that have structure changes
vIncrNodesDim = 'tp_incr_temp_nodes_' | pAppId;
IF (DimensionExists(vIncrNodesDim) >0);
	DimensionDestroy(vIncrNodesDim);
Endif;
DimensionCreate(vIncrNodesDim);

#*** No error

If (cGenerateLog @= 'Y');
	TextOutput(cTM1Log, TIMST(NOW, '\Y-\m-\d \h:\i:\s'), 'The end has been reached.');
EndIf;
#endregion
#region Data


#################################################################
## IBM Confidential
##
## OCO Source Materials
##
## BI and PM: pmpsvc
##
## (C) Copyright IBM Corp. 2008, 2009, 2010
##
## The source code for this program is not published or otherwise
## divested of its trade secrets, irrespective of what has been
## deposited with the U.S. Copyright Office.
#################################################################


#*** Log File Name
cTM1Log = cDataLog;

#permission VIEW
cLeafRightView = 'VIEW';

#permission VIEW, ANNOTATE, EDIT
cLeafRightEdit = 'EDIT';

#permission VIEW, ANNOTATE, EDIT, SUBMIT
cLeafRightSubmit = 'SUBMIT';

#permission VIEW, ANNOTATE, EDIT, SUBMIT, REJECT
cLeafRightReject = 'REJECT';

#permission VIEW
cConsolidatedRightView = 'VIEW';

#permission VIEW, ANNOTATE
cConsolidatedRightReview = 'REVIEW';

#permission VIEW, ANNOTATE, SUBMIT
cConsolidatedRightSubmit = 'SUBMIT';

#permission VIEW, ANNOTATE, SUBMIT, REJECT
cConsolidatedRightReject = 'REJECT';

#permission types
cView = 'VIEW';
cAnnotate = 'ANNOTATE';
cEdit = 'EDIT';
cReject = 'REJECT';
cSubmit = 'SUBMIT';

cCubeSecurityCube = '}CubeSecurity';
cDimensionSecurityCube = '}DimensionSecurity';
cElementAttributesPrefix = '}ElementAttributes_';

If (cGenerateLog @= 'Y');
	TextOutput(cTM1Log, TIMST(NOW, '\Y-\m-\d \h:\i:\s'), 'Security set', cSecuritySet);
EndIf;

cNone = 'NONE';
cRead = 'READ';
cWrite = 'WRITE';
cLock = 'WRITE';

#***
IF (DIMIX('}Groups', vGroup)>0);
cGroupPName = DimensionElementPrincipalName('}Groups', vGroup);
Else;
cGroupPName = '';
Endif;

IF (DIMIX(cShadowApprovalDim, vNode)>0);
cNodePName = DimensionElementPrincipalName(cShadowApprovalDim, vNode);
Else;
cNodePName = '';
Endif;

#first clean up, zero out views
IF (cGroupPName @<> '' & cNodePName @<>'' & DIMIX(cApprovalDim, cNodePName) >0);

	vTempNodeSubset = 'tp_node_' | pExecutionId;
	vShadowNodeSubset = 'tp_node_' | pExecutionId;
	#a view for this application, this node
	vTempNodeView = 'tp_temp_node_view_' | pExecutionId;
	#a view for this application and this group slice
	vTempAppView = 'tp_group_app_view_' | pExecutionId;

	IF (DIMIX(vIncrNodesDim, cNodePName) =0);
		#***create a node subset on approval dimension that contains this node only
		IF (SubsetExists(cApprovalDim, vTempNodeSubset)>0);
			SubsetDestroy(cApprovalDim, vTempNodeSubset);
		Endif;
		SubsetCreate(cApprovalDim, vTempNodeSubset);
		SubsetElementInsert(cApprovalDim, vTempNodeSubset, cNodePName, 1);

		#***create a node subset on shadow dimension that contains this node only
		IF (SubsetExists(cShadowApprovalDim, vShadowNodeSubset)>0);
			SubsetDestroy(cShadowApprovalDim, vShadowNodeSubset);
		Endif;
		SubsetCreate(cShadowApprovalDim, vShadowNodeSubset);
		SubsetElementInsert(cShadowApprovalDim, vShadowNodeSubset, cNodePName, 1);
		
		#zero out cell security permission cube on this node slice
		ViewCreate(cCellSecurityCube, vTempNodeView);
		ViewColumnDimensionSet(cCellSecurityCube, vTempNodeView, cShadowApprovalDim, 1);
		ViewSubsetAssign(cCellSecurityCube, vTempNodeView, cShadowApprovalDim, vShadowNodeSubset );
		ViewZeroOut(cCellSecurityCube, vTempNodeView);
		ViewDestroy(cCellSecurityCube, vTempNodeView);

		#zero out element security on shadow approval dimension on this node slice
		ViewCreate(cElementSecurityCube, vTempNodeView);
		ViewRowDimensionSet(cElementSecurityCube, vTempNodeView,cShadowApprovalDim , 1);
		ViewSubsetAssign(cElementSecurityCube,vTempNodeView, cShadowApprovalDim, vShadowNodeSubset );
		ViewZeroOut(cElementSecurityCube, vTempNodeView);
		ViewDestroy(cElementSecurityCube, vTempNodeView);

		#***
		#zero out application element security cube for group and application slice
		ViewCreate(cAppElementSecurityCube, vTempAppView);
		ViewRowDimensionSet(cAppElementSecurityCube, vTempAppView,cApplicationsDim , 1);
		ViewSubsetAssign(cAppElementSecurityCube, vTempAppView, cApplicationsDim, vAppSubset);
		ViewZeroOut(cAppElementSecurityCube, vTempAppView);
		ViewDestroy(cAppElementSecurityCube, vTempAppView);
	Endif;

	#*** Give read right to the attributes dimension and attribute cube of the shadow approval dimension
	cElementAttributes = cElementAttributesPrefix | cShadowApprovalDim;
	If (DimensionExists(cElementAttributes) <> 0);
		CellPutS(cRead, cDimensionSecurityCube, cElementAttributes, cGroupPName);
	EndIf;
	If (CubeExists(cElementAttributes) <> 0);
		CellPutS(cRead, cCubeSecurityCube, cElementAttributes, cGroupPName);
	EndIf;

	#***
	If (cGenerateLog @= 'Y');
		TextOutput(cTM1Log, TIMST(NOW, '\Y-\m-\d \h:\i:\s'), 'Make Application element readable for group', cGroupPName);
	EndIf;
	
	#Element security cube on }tp_applications dimension
	cApplicationsDim = cControlPrefix | 'tp_applications';
	ElementSecurityPut(cRead, cApplicationsDim, pAppId, cGroupPName);

	# Update permission on consoidated node 
	If (DTYPE(cShadowApprovalDim, cNodePName) @= 'C');
		If (cGenerateLog @= 'Y');
			TextOutput(cTM1Log, TIMST(NOW, '\Y-\m-\d \h:\i:\s'), 'Consolidation node', cNodePName, cGroupPName);
		EndIf;
	
		#***
		If (cGenerateLog @= 'Y');
			TextOutput(cTM1Log, TIMST(NOW, '\Y-\m-\d \h:\i:\s'), 'Assign rights to self', cNodePName, cGroupPName);
		EndIf;

		If (vRight @= cConsolidatedRightReject);
			CellPutS(cRead, cCellSecurityCube, cNodePName, cSubmit, cGroupPName);
			CellPutS(cRead, cCellSecurityCube, cNodePName, cReject, cGroupPName);
			CellPutS(cNone, cCellSecurityCube, cNodePName, cEdit, cGroupPName);
			CellPutS(cRead, cCellSecurityCube, cNodePName, cAnnotate, cGroupPName);
			CellPutS(cRead, cCellSecurityCube, cNodePName, cView, cGroupPName);
			If (cGenerateLog @= 'Y');
				TextOutput(cTM1Log, TIMST(NOW, '\Y-\m-\d \h:\i:\s'), 'ElementSecurityPut for submit and review rights passing down from the parent ' | cNodePName | ',' | cRead | ',' | cGroupPName);
			EndIf;
			ElementSecurityPut(cWrite, cShadowApprovalDim, cNodePName, cGroupPName);
		ElseIf (vRight @= cConsolidatedRightSubmit);
			CellPutS(cRead, cCellSecurityCube, cNodePName, cSubmit, cGroupPName);
			CellPutS(cNone, cCellSecurityCube, cNodePName, cReject, cGroupPName);
			CellPutS(cNone, cCellSecurityCube, cNodePName, cEdit, cGroupPName);
			CellPutS(cRead, cCellSecurityCube, cNodePName, cAnnotate, cGroupPName);
			CellPutS(cRead, cCellSecurityCube, cNodePName, cView, cGroupPName);
			If (cGenerateLog @= 'Y');
				TextOutput(cTM1Log, TIMST(NOW, '\Y-\m-\d \h:\i:\s'), 'ElementSecurityPut for submit ' | cNodePName | ',' | cRead | ',' | cGroupPName);
			EndIf;
			ElementSecurityPut(cWrite, cShadowApprovalDim, cNodePName, cGroupPName);
		ElseIf (vRight @= cConsolidatedRightReview);
			CellPutS(cNone, cCellSecurityCube, cNodePName, cSubmit, cGroupPName);
			CellPutS(cNone, cCellSecurityCube, cNodePName, cReject, cGroupPName);
			CellPutS(cNone, cCellSecurityCube, cNodePName, cEdit, cGroupPName);
			CellPutS(cRead, cCellSecurityCube, cNodePName, cAnnotate, cGroupPName);
			CellPutS(cRead, cCellSecurityCube, cNodePName, cView, cGroupPName);
			If (cGenerateLog @= 'Y');
				TextOutput(cTM1Log, TIMST(NOW, '\Y-\m-\d \h:\i:\s'), 'ElementSecurityPut for review ' | cNodePName | ',' | cRead | ',' | cGroupPName);
			EndIf;
			ElementSecurityPut(cWrite, cShadowApprovalDim, cNodePName, cGroupPName);
		ElseIf (vRight @= cConsolidatedRightView);
			CellPutS(cNone, cCellSecurityCube, cNodePName, cSubmit, cGroupPName);
			CellPutS(cNone, cCellSecurityCube, cNodePName, cReject, cGroupPName);
			CellPutS(cNone, cCellSecurityCube, cNodePName, cEdit, cGroupPName);
			CellPutS(cNone, cCellSecurityCube, cNodePName, cAnnotate, cGroupPName);
			CellPutS(cRead, cCellSecurityCube, cNodePName, cView, cGroupPName);
			If (cGenerateLog @= 'Y');
				TextOutput(cTM1Log, TIMST(NOW, '\Y-\m-\d \h:\i:\s'), 'ElementSecurityPut for view ' | cNodePName | ',' | cRead | ',' | cGroupPName);
			EndIf;
			ElementSecurityPut(cWrite, cShadowApprovalDim, cNodePName, cGroupPName);
		EndIf;
	Else;
		If (cGenerateLog @= 'Y');
			TextOutput(cTM1Log, TIMST(NOW, '\Y-\m-\d \h:\i:\s'), 'Leaf node', cNodePName);
		EndIf;

		If (vRight @= cLeafRightReject);
			CellPutS(cRead, cCellSecurityCube, cNodePName, cSubmit, cGroupPName);
			CellPutS(cRead, cCellSecurityCube, cNodePName, cReject, cGroupPName);
			CellPutS(cRead, cCellSecurityCube, cNodePName, cEdit, cGroupPName);
			CellPutS(cRead, cCellSecurityCube, cNodePName, cAnnotate, cGroupPName);
			CellPutS(cRead, cCellSecurityCube, cNodePName, cView, cGroupPName);
			If (cGenerateLog @= 'Y');
				TextOutput(cTM1Log, TIMST(NOW, '\Y-\m-\d \h:\i:\s'), 'ElementSecurityPut for ' | cNodePName | ',' | vRight | ',' | cRead | ',' | cGroupPName);
			EndIf;
			ElementSecurityPut(cLock, cShadowApprovalDim, cNodePName, cGroupPName);
		ElseIf (vRight @= cLeafRightSubmit);
			CellPutS(cRead, cCellSecurityCube, cNodePName, cSubmit, cGroupPName);
			CellPutS(cNone, cCellSecurityCube, cNodePName, cReject, cGroupPName);
			CellPutS(cRead, cCellSecurityCube, cNodePName, cEdit, cGroupPName);
			CellPutS(cRead, cCellSecurityCube, cNodePName, cAnnotate, cGroupPName);
			CellPutS(cRead, cCellSecurityCube, cNodePName, cView, cGroupPName);
			If (cGenerateLog @= 'Y');
				TextOutput(cTM1Log, TIMST(NOW, '\Y-\m-\d \h:\i:\s'), 'ElementSecurityPut for ' | cNodePName | ',' | vRight | ',' | cRead | ',' | cGroupPName);
			EndIf;
			ElementSecurityPut(cLock, cShadowApprovalDim, cNodePName, cGroupPName);
		ElseIf (vRight @= cLeafRightEdit);
			CellPutS(cNone, cCellSecurityCube, cNodePName, cSubmit, cGroupPName);
			CellPutS(cNone, cCellSecurityCube, cNodePName, cReject, cGroupPName);
			CellPutS(cRead, cCellSecurityCube, cNodePName, cEdit, cGroupPName);
			CellPutS(cRead, cCellSecurityCube, cNodePName, cAnnotate, cGroupPName);
			CellPutS(cRead, cCellSecurityCube, cNodePName, cView, cGroupPName);
			If (cGenerateLog @= 'Y');
				TextOutput(cTM1Log, TIMST(NOW, '\Y-\m-\d \h:\i:\s'), 'ElementSecurityPut for ' | cNodePName | ',' | vRight | ',' | cWrite | ',' | cGroupPName);
			EndIf;
			ElementSecurityPut(cWrite, cShadowApprovalDim, cNodePName, cGroupPName);
		ElseIf (vRight @= cLeafRightView);
			CellPutS(cNone, cCellSecurityCube, cNodePName, cSubmit, cGroupPName);
			CellPutS(cNone, cCellSecurityCube, cNodePName, cReject, cGroupPName);
			CellPutS(cNone, cCellSecurityCube, cNodePName, cEdit, cGroupPName);
			CellPutS(cNone, cCellSecurityCube, cNodePName, cAnnotate, cGroupPName);
			CellPutS(cRead, cCellSecurityCube, cNodePName, cView, cGroupPName);
			If (cGenerateLog @= 'Y');
				TextOutput(cTM1Log, TIMST(NOW, '\Y-\m-\d \h:\i:\s'), 'ElementSecurityPut for ' | cNodePName | ',' | vRight | ',' | cRead | ',' | cGroupPName);
			EndIf;
			ElementSecurityPut(cRead, cShadowApprovalDim, cNodePName, cGroupPName);
		EndIf;
	EndIf;

	#***
	#zero out RDCLS intermediate cube on the group, node and application slice, then update the slice again
	cubeSeparater = '*';
	vPosCube = 0;
	vStringToScan = pCubeInfo;
	vPosCube = SCAN(cubeSeparater, vStringToScan);

	While (vPosCube >0);
		vCubeName = SUBST(vStringToScan, 1, vPosCube-1);
		vFlagCube = SUBST(vStringToScan, vPosCube+1, 1);
	
		If (vFlagCube @= 'A' );
			vRDCLSIntermediateCube = '}tp_intermediate_RDCLS}' | vCubeName;
			vIntermediateSecurityMeasureDim = '}tp_intermediate_security_measures';
		
			IF (cubeExists(vRDCLSIntermediateCube) >0);
				IF (DIMIX(vIncrNodesDim, cNodePName) =0);
					ViewCreate(vRDCLSIntermediateCube, vTempNodeView );
					ViewColumnDimensionSet(vRDCLSIntermediateCube, vTempNodeView , cApprovalDim, 1);
					ViewSubsetAssign(vRDCLSIntermediateCube, vTempNodeView , cApprovalDim, vTempNodeSubset );
					ViewTitleDimensionSet(vRDCLSIntermediateCube, vTempNodeView , vAppDim);
					ViewSubsetAssign(vRDCLSIntermediateCube, vTempNodeView , vAppDim, vAppSubset);
					ViewZeroOut(vRDCLSIntermediateCube, vTempNodeView );
					ViewDestroy(vRDCLSIntermediateCube, vTempNodeView );
				Endif;

				#***
				versionIndex = 0;
				approvalIndex = 0;
				dimensionIndex = 1;
				While (dimensionIndex > 0 ); 
					cCubeDimensionName = TABDIM(vCubeName, dimensionIndex);
					If (cCubeDimensionName @= '');
						dimensionIndex = -1;
					Else;
						IF (cCubeDimensionName @=cVersionDim);
							versionIndex = dimensionIndex;
						Endif;
				
						IF (cCubeDimensionName @= cApprovalDim );
							approvalIndex =dimensionIndex ;
						Endif;

					EndIf;

					dimensionIndex = dimensionIndex + 1;
				End;

				IF (versionIndex < approvalIndex);
					versionFirst = 'Y';
				Endif;

				#***
				vReturnValue = ExecuteProcess( '}tp_rights_update_IM_cube_by_node_group','pExecutionId', pExecutionId,
					'pAppId', pAppId, 'pCube', vCubeName, 'pApprovalDim', cApprovalDim, 
					'pVersionDim', cVersionDim, 'pVersionSlicesWrite', cVersionSlicesWrite, 'pVersionSlicesRead', cVersionSlicesRead, 
					'pApprovalNode', cNodePName,'pGroup', cGroupPName, 'pVersionIndex', NumberToString(versionIndex), 'pApprovalIndex', NumberToString(approvalIndex), 'pVersionFirst', versionFirst);
				If (vReturnValue <> ProcessExitNormal());
					ProcessError;
				EndIf;

				vReturnValue = ExecuteProcess( '}tp_rights_update_static_by_node_group','pExecutionId', pExecutionId,
					'pAppId', pAppId, 'pCube', vCubeName, 'pApprovalDim', cApprovalDim, 'pVersionDim', cVersionDim,
					'pApprovalNode', cNodePName,'pGroup', cGroupPName,  'pVersionIndex', NumberToString(versionIndex), 'pApprovalIndex', NumberToString(approvalIndex), 'pVersionFirst', versionFirst);
				If (vReturnValue <> ProcessExitNormal());
					ProcessError;
				EndIf;
			Endif;
		Endif;

		vStringToScan = SUBST(vStringToScan, vPosCube +3, LONG(vStringToScan)-vPosCube);
		vPosCube = SCAN(cubeSeparater, vStringToScan);
	End;


	#Insert this node into the temp dimension
	DimensionElementInsertDirect(vIncrNodesDim, '',cNodePName ,'N');

	#***clean up 
	IF (SubsetExists(cApprovalDim, vTempNodeSubset)>0);
		SubsetDestroy(cApprovalDim, vTempNodeSubset);
	Endif;

	IF (SubsetExists(cShadowApprovalDim, vShadowNodeSubset)>0);
		SubsetDestroy(cShadowApprovalDim, vShadowNodeSubset);
	Endif;

Endif;

#*** No error

If (cGenerateLog @= 'Y');
	TextOutput(cTM1Log, TIMST(NOW, '\Y-\m-\d \h:\i:\s'), 'The end has been reached.');
EndIf;
#endregion
#region Epilog


#################################################################
## IBM Confidential
##
## OCO Source Materials
##
## BI and PM: pmpsvc
##
## (C) Copyright IBM Corp. 2008, 2009, 2010
##
## The source code for this program is not published or otherwise
## divested of its trade secrets, irrespective of what has been
## deposited with the U.S. Copyright Office.
#################################################################

#*** Log File Name
cTM1Log = cEpilogLog;

If (cGenerateLog @= 'Y');
	TextOutput(cTM1Log, TIMST(NOW, '\Y-\m-\d \h:\i:\s'), 'Starting epilog.');
EndIf;

savedataall();

#***
IF (SubsetExists(vAppDim, vAppSubset) >0);
	SubsetDestroy(vAppDim, vAppSubset);
Endif;

IF (SubsetExists(cApplicationsDim, vAppSubset) >0);
	subsetDestroy(cApplicationsDim, vAppSubset);
Endif;

#***
IF (DimensionExists(vIncrNodesDim) >0);
	DimensionDestroy(vIncrNodesDim);
Endif;

#***
IF (CubeExists(cElementSecurityCube )>0);
	CubeSetLogChanges(cElementSecurityCube , 1);
Endif;

IF (CubeExists(cCellSecurityCube )>0);
	CubeSetLogChanges(cCellSecurityCube , 1);
Endif;

cubeSeparater = '*';
vPosCube = 0;
vStringToScan = pCubeInfo;
vPosCube = SCAN(cubeSeparater, vStringToScan);

While (vPosCube >0);
	vCubeName = SUBST(vStringToScan, 1, vPosCube-1);
	vFlagCube = SUBST(vStringToScan, vPosCube+1, 1);
	
	If (vFlagCube @= 'A' );
		vRDCLSIntermediateCube = '}tp_intermediate_RDCLS}' | vCubeName;
		
		IF (cubeExists(vRDCLSIntermediateCube) >0);
			CubeSetLogChanges(vRDCLSIntermediateCube, 1);
		Endif;
	Endif;

	vStringToScan = SUBST(vStringToScan, vPosCube +3, LONG(vStringToScan)-vPosCube);
	vPosCube = SCAN(cubeSeparater, vStringToScan);
End;

#*** No error

If (cGenerateLog @= 'Y');
	TextOutput(cTM1Log, TIMST(NOW, '\Y-\m-\d \h:\i:\s'), 'The end has been reached.');
EndIf;
#endregion